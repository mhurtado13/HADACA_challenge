##################################################################################################
### PLEASE only edit the program function between YOUR CODE BEGINS/ENDS HERE                   ###
##################################################################################################

#' The function to predict the A matrix
#' In the provided example, we use basic non-negative least squares (package "nnls"), which consists in minimizing the error term $||Mix - Ref \times Prop||^2$ with only positive entries in the prop matrix.
#'
#' @param mix a matrix of bulk samples (columns) and features (rows)
#' @param ref a matrix of pure cell types (columns) and features (rows)
#' @param ... other parameters that will be ignored
#' 
#' @return the predicted A matrix
#' @examples
#' 
program = function(mix_rna = mix_rna, ref_bulkRNA = ref_bulkRNA, mix_met = mix_met,
                   ref_met = ref_met, ...) {
  
  ##
  ## YOUR CODE BEGINS HERE
  ##
  
  rm(list = ls()); gc()
  
  if (!requireNamespace("biomaRt", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }
    BiocManager::install("biomaRt")
  }
  library(biomaRt)
  
  if (!requireNamespace("AnnotationHub", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }
    BiocManager::install("AnnotationHub")
  }
  library(AnnotationHub)
  
  if (!requireNamespace("GenomicFeatures", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }
    BiocManager::install("GenomicFeatures")
  }
  library(GenomicFeatures)
  
  if (!requireNamespace("dplyr", quietly = TRUE)) {
    install.packages("dplyr")
  }
  library(dplyr)
  
  if (!requireNamespace("GenomicRanges", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }
    BiocManager::install("GenomicRanges")
  }
  library(GenomicRanges)
  
  if (!requireNamespace("IlluminaHumanMethylation450kanno.ilmn12.hg19", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }
    BiocManager::install("IlluminaHumanMethylation450kanno.ilmn12.hg19")
  }
  library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
  
  data("IlluminaHumanMethylation450kanno.ilmn12.hg19")
  
  # mix_rna <- readRDS(file = "/home/benoitcl/HADACA/starting_kit_phase2-3/data/mixes1_VIVO_pdac.rds")$mix_rna
  # ref_bulkRNA <- readRDS("/home/benoitcl/HADACA/starting_kit_phase2-3/data/reference_pdac.rds")$ref_bulkRNA

  gene_list <- gene_list <- read.table(file = "attachement/peng_gene_list.txt",
                                       sep = ",",
                                       header = TRUE,
                                       check.names = FALSE) %>%
                filter(p_adj < 0.00000000005)
  
  nrow(gene_list)

  bulk_genes <- rownames(mix_rna)
  
  # Liste des gènes dans gene_list
  marker_genes <- unique(gene_list$`HUGO symbols`)
  
  # Gènes communs
  common_genes <- intersect(bulk_genes, marker_genes)
  
  # Filtrer les données bulk RNA pour conserver uniquement les gènes communs
  filtered_bulkRNA <- mix_rna[common_genes, ]
  
  # Filtrer gene_list pour ne conserver que les gènes communs
  filtered_gene_list <- gene_list[gene_list$gene_names %in% common_genes, ]
  
  results <- list()  # To store results
  mix_rna <- mix_rna[rownames(mix_rna) %in% gene_list$`HUGO symbols`,]
  ref_bulkRNA <- ref_bulkRNA[rownames(ref_bulkRNA) %in% gene_list$`HUGO symbols`,]
  for (i in 1:ncol(mix_rna)) {
    y_sample <- mix_rna[, i]  # Bulk data for sample i
    
    # Perform RLR using rlm
    fit <- MASS::rlm(y_sample ~ 0 + ref_bulkRNA, method = "MM")  # No intercept, only cell types
    
    # Normalize coefficients to sum to 1
    proportions <- fit$coefficients
    normalized_proportions <- proportions / sum(proportions)
    
    # Store normalized proportions
    results[[i]] <- normalized_proportions
  }
  
  # Combine results into a matrix
  estimated_proportions_rna <- do.call(cbind, results)
  colnames(estimated_proportions_rna) <- colnames(mix_rna)
  rownames(estimated_proportions_rna) <- colnames(ref_bulkRNA)
  
  # mix_met <- readRDS(file = "/home/benoitcl/HADACA/starting_kit_phase2-3/data/mixes1_SDE5_pdac.rds")$mix_met
  # ref_met <- readRDS("/home/benoitcl/HADACA/starting_kit_phase2-3/data/reference_pdac.rds")$ref_met
  # mix_met <- readRDS(file = "/home/benoitcl/HADACA/starting_kit_phase2-3/data/mixes1_VIVO_pdac.rds")$mix_met
  # ref_met <- readRDS("/home/benoitcl/HADACA/starting_kit_phase2-3/data/reference_pdac.rds")$ref_met

  cpg_annotation <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
  # Subset annotation for relevant CpGs
  mapped_cpgs <- cpg_annotation[rownames(mix_met), ]
  cpg_granges <- GRanges(
    seqnames = mapped_cpgs$chr,
    ranges = IRanges(start = mapped_cpgs$pos, end = mapped_cpgs$pos),
    CpG_ID = rownames(mapped_cpgs)
  )
  cpg_granges_expanded <- GRanges(seqnames = seqnames(cpg_granges),
                                  ranges = IRanges(start = start(cpg_granges) - 1, 
                                                   end = end(cpg_granges) + 1))
  ah <- AnnotationHub()
  # Query for UCSC data (hg19)
  grch19 <- query(ah, c("Homo sapiens", "Ensembl", "release", "gtf"))[[1]]
  
  txdb <- txdbmaker::makeTxDbFromGRanges(grch19)
  #mcols(grch19) <- "gene"
  gene_annotations <- genes(txdb)
  
  ensembl <- useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl", "https://feb2014.archive.ensembl.org")
  
  # Get Ensembl gene IDs from gene annotations
  ensembl_ids <- gene_annotations$gene_id  # Ensembl gene IDs
  
  # Query biomaRt to get HGNC symbols for Ensembl IDs
  conversion <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                      filters = "ensembl_gene_id", 
                      values = ensembl_ids,
                      mart = ensembl)
  
  # Merge to add HGNC symbols to your gene annotations
  gene_annotations <- merge(gene_annotations, conversion, by.x = "gene_id", by.y = "ensembl_gene_id", all.x = TRUE)
  
  # Filter only genes matching HGNC symbols
  #filtered_genes <- gene_annotations %>% filter(hgnc_symbol %in% gene_list$`HUGO symbols`)
  filtered_genes <- gene_annotations %>% filter(hgnc_symbol %in% rownames(mix_rna))
  
  filtered_granges <- GRanges(seqnames = paste0("chr",filtered_genes$seqnames),
                              ranges = IRanges(start = filtered_genes$start, end = filtered_genes$end),
                              hgnc_symbol = filtered_genes$hgnc_symbol)
  
  # Find overlaps
  overlaps <- findOverlaps(cpg_granges,
                           filtered_granges,
                           type = "any")

  # Get CpGs that do not overlap
  non_overlapping_cpgs <- cpg_granges[-queryHits(overlaps)]
  
  # Filter methylation data
  mix_met <- mix_met[non_overlapping_cpgs$CpG_ID, ]
  
  results <- list()  # To store results
  # mix_met <- mix_met[rownames(mix_met) %in% gene_list$`HUGO symbols`,]
  # ref_met <- ref_met[rownames(ref_met) %in% gene_list$`HUGO symbols`,]
  #ref_met <- ref_met[rownames(ref_met) %in% rownames(mix_met),]
  ref_met <- ref_met[rownames(mix_met),]
  
  for (i in 1:ncol(mix_met)) {
    y_sample <- mix_met[, i]  # Bulk data for sample i
    
    # Perform RLR using rlm
    fit <- MASS::rlm(y_sample ~ 0 + ref_met, method = "MM")  # No intercept, only cell types
    
    # Normalize coefficients to sum to 1
    proportions <- fit$coefficients
    normalized_proportions <- proportions / sum(proportions)
    
    # Store normalized proportions
    results[[i]] <- normalized_proportions
  }
  
  # Combine results into a matrix
  estimated_proportions_meth <- do.call(cbind, results)
  colnames(estimated_proportions_meth) <- colnames(mix_met)
  rownames(estimated_proportions_meth) <- colnames(ref_met)
  
  print("dim(estimated_proportions_meth)")
  print(colnames(estimated_proportions_meth))
  dim(estimated_proportions_meth)
  print("dim(estimated_proportions_rna)")
  print(colnames(estimated_proportions_rna))
  dim(estimated_proportions_rna)
  # Step 1: Compute the average of the two dataframes
  average_proportions <- (estimated_proportions_meth + estimated_proportions_rna) / 2
  
  average_proportions["basal",] <- 0.8*average_proportions["basal",]
  average_proportions["classic",] <- 1.2*average_proportions["classic",]
  
  # Step 2: Normalize each column to sum to 1
  estimated_proportions <- sweep(average_proportions, 2, colSums(average_proportions), FUN = "/")
  
  estimated_proportions[is.nan(estimated_proportions)] <- 0.2
  
  return(estimated_proportions)
  
  ##
  ## YOUR CODE ENDS HERE
  ##
}


##############################################################
### Generate a prediction file /!\ DO NOT CHANGE THIS PART ###
##############################################################

validate_pred <- function(pred, nb_samples = ncol(mix_rna) , nb_cells= ncol(ref_rna),col_names = colnames(ref_met) ){

  error_status = 0   # 0 means no errors, 1 means "Fatal errors" and 2 means "Warning"
  error_informations = ''

  ## Ensure that all sum ofcells proportion approximately equal 1
  if (!all(sapply(colSums(pred), function(x) isTRUE(all.equal(x, 1) )))) {
    msg = "The prediction matrix does not respect the laws of proportions: the sum of each columns should be equal to 1\n"
    error_informations = paste(error_informations,msg)
    error_status = 2
  }

  ##Ensure that the prediction have the correct names ! 
  if(! setequal(rownames(pred),col_names) ){
    msg = paste0(    "The row names in the prediction matrix should match: ", toString(col_names),"\n")
    error_informations = paste(error_informations,msg)
    error_status = 2
  }

  ## Ensure that the prediction return the correct number of samples and  number of cells. 
  if (nrow(pred) != nb_cells  | ncol(pred) != nb_samples)  {
    msg= paste0('The prediction matrix has the dimention: ',toString(dim(pred))," whereas the dimention: ",toString(c(nb_cells,nb_samples))," is expected\n"   )
    error_informations = paste(error_informations,msg)
    error_status = 1
  }

  if(error_status == 1){
    # The error is blocking and should therefor stop the execution. 
    # tryCatch(message("hello\n"), message=function(e){cat("goodbye\n")})  use this here ? 
    stop(error_informations)
  }
  if(error_status == 2){
    print("Warning: ")
    warning(error_informations)
  }  
}

dir_name = paste0("data",.Platform$file.sep)
dataset_list = list.files(dir_name,pattern="mixes*")

reference_data <- readRDS(file =  paste0(dir_name, "reference_pdac.rds"))

predi_list = list()
for (dataset_name in dataset_list){

  print(paste0("generating prediction for dataset:",toString(dataset_name) ))

  mixes_data <- readRDS(file = paste0(dir_name, dataset_name))

  if ("mix_rna" %in% names(mixes_data)) {
    mix_rna = mixes_data$mix_rna
  } else {
    mix_rna = mixes_data
  }
  if ("mix_met" %in% names(mixes_data)) {
    mix_met = mixes_data$mix_met  
  } else {
    mix_met = NULL
  }

  if ("ref_bulkRNA" %in% names(reference_data)) {
    ref_bulkRNA = reference_data$ref_bulkRNA
  } else {
    ref_bulkRNA = reference_data
  }
  if ("ref_met" %in% names(reference_data)) {
    ref_met = reference_data$ref_met  
  } else {
    ref_met = NULL
  }
  if ("ref_scRNA" %in% names(reference_data)) {
    ref_scRNA = reference_data$ref_scRNA  
  } else {
    ref_scRNA = NULL
  }

  # we use the previously defined function 'program' to estimate A :
  pred_prop <- program(mix_rna = mix_rna, ref_bulkRNA = ref_bulkRNA,
                       mix_met = mix_met, ref_met = ref_met, ref_scRNA = ref_scRNA)
  
  #codabench objects :
  #pred_prop <- program(mix_rna, ref_bulkRNA, mix_met=mix_met, ref_met=ref_met, ref_scRNA=ref_scRNA)
  #program = function(mix_met=NULL, ref_met=NULL, mix = NULL, ref = NULL, ...) {

  validate_pred(pred_prop,nb_samples = ncol(mix_rna), nb_cells = ncol(ref_bulkRNA),col_names = colnames(ref_met))
  predi_list[[dataset_name]] = pred_prop

}


##############################################################
### Check the prediction /!\ DO NOT CHANGE THIS PART ###
##############################################################


###############################
### Code submission mode

print("")
for (package in c("zip") ) {
  if ( !{ package %in% installed.packages( ) } ) {
        print(x = paste("Installation of ", package, sep = "") )
        install.packages(
            pkgs = "zip"
          , repos = "https://cloud.r-project.org"
        )
    } 
}


# we generate a zip file with the 'program' source code

if ( !dir.exists(paths = "submissions") ) {
    dir.create(path = "submissions")
}

# we save the source code as a R file named 'program.R' :
dump(
    list = c("program")
    # list = new_functions
  , file = paste0("submissions", .Platform$file.sep, "program.R")
)

date_suffix = format(x = Sys.time( ), format = "%Y_%m_%d_%H_%M_%S")

zip_program <- paste0("submissions", .Platform$file.sep, "program_", date_suffix, ".zip")
zip::zip(zipfile= zip_program
  , files   = paste0("submissions", .Platform$file.sep, "program.R")
  , mode = "cherry-pick")

if(dir.exists("attachement")) {
  zip::zip_append(
      zipfile = zip_program
      , files= paste0("attachement", .Platform$file.sep)
    , mode = "cherry-pick"
  )
}

zip::zip_list(zip_program)
print(x = zip_program)

# # we create the associated zip file :
# zip_program <- paste0("submissions", .Platform$file.sep, "program_", date_suffix, ".zip")
# zip::zip(zipfile= zip_program
#                 , files= paste0("submissions", .Platform$file.sep, "program.R")
#                 , mode = "cherry-pick"
#                 )

# zip::zip_list(zip_program)
# print(x = zip_program)

###############################
### Result submission mode  

#  Generate a zip file with the prediction
if ( !dir.exists(paths = "submissions") ) {
    dir.create(path = "submissions")
}

prediction_name = "prediction.rds"

## we save the estimated A matrix as a rds file named 'results.rds' :
saveRDS(
object = predi_list
, file   = paste0("submissions", .Platform$file.sep, prediction_name)) 

# write_rds(pred_prop, file = "prediction_hugo.rds")

## we create the associated zip file :
zip_results <- paste0("submissions", .Platform$file.sep, "results_", date_suffix, ".zip")
zip::zipr(
         zipfile = zip_results
       , files   = paste0("submissions", .Platform$file.sep, c(prediction_name) )
     )
print(x = zip_results)

sessionInfo( )

###############################################################
### How to submit the zip file? /!\ DO NOT CHANGE THIS PART ###
###############################################################
#
# The code above generates the files *`r zip_program`*  and *`r zip_results`*  (the 1st one for code submission, the 2nd one for result submission).
#
# Submit the zip submission file on the challenge in the `My Submission` tab, fill the metadata, select the task you want to submit to and upload your submission files
#
# On the codalab challenge web page, The *STATUS* become :
#   - Submitting
#   - Submitted
#   - Running
#   - Finished
#
# When it’s finished :
#   - You refresh the page and click on the green button 'add to leaderboard' to see your score
#   - If enable, details for report could be downloaded by clicking on your submission
#   - Some execution logs are available to check and or download.
#   - Metadata are editable when you click on your submission
#   - Leader board is updated in the `Results` tab.
#
